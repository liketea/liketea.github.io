<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误');
                history.back();
            }
        }
    })();
</script>

<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-feather.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/feather-32x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/feather-16x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/apple-touch-icon-feather.png?v=5.1.4" color="#222">





  <meta name="keywords" content="数据结构与算法," />





  <link rel="alternate" href="/atom.xml" title="Like" type="application/atom+xml" />






<meta name="description" content="数论的理论部分详见 math 专题，本部分仅讨论数论相关的核心算法，及其在实际问题中的应用。 整除性与素数辗转相除法 欧几里得算法（Euclidean algorithm）：也称为辗转相除法，通常用于计算两个整数的最大公约数，对$0\leqslant m&lt;n$，EA用到以下递推式：   \begin{align*}  &amp;gcd(0,n)&#x3D;n;\\ &amp;gcd(m,n)&#x3D;gcd(n\%m,m),">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法：数论">
<meta property="og:url" content="http://liketea.xyz/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E8%AE%BA/index.html">
<meta property="og:site_name" content="Like">
<meta property="og:description" content="数论的理论部分详见 math 专题，本部分仅讨论数论相关的核心算法，及其在实际问题中的应用。 整除性与素数辗转相除法 欧几里得算法（Euclidean algorithm）：也称为辗转相除法，通常用于计算两个整数的最大公约数，对$0\leqslant m&lt;n$，EA用到以下递推式：   \begin{align*}  &amp;gcd(0,n)&#x3D;n;\\ &amp;gcd(m,n)&#x3D;gcd(n\%m,m),">
<meta property="og:locale">
<meta property="og:image" content="https://likeitea-1257692904.cos.ap-guangzhou.myqcloud.com/liketea_blog/17-18-37.png">
<meta property="article:published_time" content="2017-10-10T12:13:53.000Z">
<meta property="article:modified_time" content="2021-06-02T10:44:40.928Z">
<meta property="article:author" content="Like">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://likeitea-1257692904.cos.ap-guangzhou.myqcloud.com/liketea_blog/17-18-37.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://liketea.xyz/数据结构与算法/数据结构与算法/数据结构与算法：数论/"/>





  <title>数据结构与算法：数论 | Like</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Like</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">哈哈哈</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-top">
          <a href="/top/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-signal"></i> <br />
            
            排行榜
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-rank">
          <a href="/rank/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-signal"></i> <br />
            
            rank
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://liketea.xyz/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://joeschmoe.io/api/v1/random">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Like">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">数据结构与算法：数论</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T20:13:53+08:00">
                2017-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-06-02T18:44:40+08:00">
                2021-06-02
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E8%AE%BA/" class="leancloud_visitors" data-flag-title="数据结构与算法：数论">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  41
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>数论的理论部分详见 math 专题，本部分仅讨论数论相关的核心算法，及其在实际问题中的应用。</p>
<h2 id="整除性与素数"><a href="#整除性与素数" class="headerlink" title="整除性与素数"></a>整除性与素数</h2><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><ul>
<li>欧几里得算法（Euclidean algorithm）：也称为辗转相除法，通常用于计算两个整数的最大公约数，对$0\leqslant m&lt;n$，EA用到以下递推式：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*} 
&gcd(0,n)=n;\\
&gcd(m,n)=gcd(n\%m,m),\ m>0
\end{align*}</script><ul>
<li>分析：时间复杂度为$O(lgn)$，具体证明参见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">拉梅定理</a></li>
</ul>
<h4 id="计算最大公约数"><a href="#计算最大公约数" class="headerlink" title="计算最大公约数"></a>计算最大公约数</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">m,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回m,n的最大公约数。无所谓大小，m为除数，n为被除数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        m,n = n%m,m</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">m,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;更加简洁的递归式&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> gcd(n%m,m) <span class="keyword">if</span> m <span class="keyword">else</span> n</span><br></pre></td></tr></table></figure></div>
<h4 id="计算最小公倍数"><a href="#计算最小公倍数" class="headerlink" title="计算最小公倍数"></a>计算最小公倍数</h4><p>最小公倍数和最大公约数有以下关系：</p>
<script type="math/tex; mode=display">
gcd(m,n)*lcm(m,n)=m*n</script><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm</span>(<span class="params">m,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回m,n的最小公倍数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> m * n /gcd(m,n)</span><br></pre></td></tr></table></figure></div>
<h4 id="求解贝祖方程"><a href="#求解贝祖方程" class="headerlink" title="求解贝祖方程"></a>求解贝祖方程</h4><p>扩展欧几里得算法（Extended Euclidean algorithm）：在求得gcd(m,n)的同时，一定能找到整数x,y（其中一个可能是负数），使得它们满足贝祖等式：</p>
<script type="math/tex; mode=display">
mx + ny = gcd(m,n)</script><p>由欧几里得算法递推过程可得：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
\begin{align*} 
&gcd(0,n)=n\\
&gcd(m,n)=gcd(n\%m,m)\\
&mx+ny=gcd(m,n)\\
&(n\%m)x_1+my_1=gcd(n\%m,m)\\
&n\%m=n-\left \lfloor \frac{n}{m} \right \rfloor m
\end{align*}
\end{matrix}\right.</script><p>整理化简得 a,b 的递推式 $xm+yn=(y_1-x_1\left \lfloor \frac{n}{m} \right \rfloor)m+x_1n$，即：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
\begin{align*} 
&x=y_1-x_1\left \lfloor \frac{n}{m} \right \rfloor\\ 
&y=x_1\\
&x_{end}=0\\
&y_{end}=1
\end{align*}
\end{matrix}\right.</script><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bz</span>(<span class="params">m,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;求解贝祖方程x*m+y*n=gcd(m,n)，返回一组(x,y)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    x,y = bz(n%m,m)</span><br><span class="line">    <span class="keyword">return</span> y-x*(n/m),x</span><br></pre></td></tr></table></figure></div>
<p>贝祖定理(Bézout’s identity)：整数不定方程 $mx+ny=c$ 有解（无穷多个解）的充要条件是$gcd(m,n)\mid c$。</p>
<p>如果贝祖方程有解，则一定有无穷解，设$(x_0,y_0)$是$mx+ny=gcd(m,n)$由辗转相除法得到的一个解，$d=gcd(m,n)$，则$mx+ny=c$的通解可表示为：</p>
<script type="math/tex; mode=display">
\left\{\left({\frac {c}{d}}x_{0}+{\frac {kn}{d}},\ {\frac {c}{d}}y_{0}-{\frac {km}{d}}\right)\mid k\in \mathbb {Z} \right\}</script><p>推论：$mx+ny=1$有解的充要条件为gcd(m,n)=1，即m,n互素。</p>
<h4 id="592-分数加减运算"><a href="#592-分数加减运算" class="headerlink" title="[592] 分数加减运算"></a>[592] 分数加减运算</h4><ul>
<li>问题：给定一个表示分数加减运算表达式的字符串，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:&quot;-1/2+1/2&quot;</span><br><span class="line">输出: &quot;0/1&quot;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：通过最小公倍数通分，通过最大公约数约分<ol>
<li>找到所有单元+-x/y，进而得到所有分子分母，</li>
<li>求分母最小公倍数</li>
<li>通分x*lcm/y求和，得到最终的分子、分母</li>
<li>最后再求最终分子分母的最大公约数</li>
<li>分子分母除以最大公约得到最简分数</li>
</ol>
</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fractionAddition</span>(<span class="params">self, expression</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type expression: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">        <span class="keyword">if</span> a &lt; b:</span><br><span class="line">            a,b = b,a</span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            a,b = b,a%b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lcm</span>(<span class="params">a,b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a * b /gcd(a,b)</span><br><span class="line">    </span><br><span class="line">    parts = []</span><br><span class="line">    part = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> expression:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&#x27;+-&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> part:</span><br><span class="line">                parts.append(part)</span><br><span class="line">                part = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        part += c</span><br><span class="line">    <span class="keyword">if</span> part: parts.append(part)</span><br><span class="line">        </span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> parts:</span><br><span class="line">        cur = p.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        x.append(<span class="built_in">int</span>(cur[<span class="number">0</span>]))</span><br><span class="line">        y.append(<span class="built_in">int</span>(cur[<span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># print x,y,parts</span></span><br><span class="line">    lcm_y = reduce(lcm,y)</span><br><span class="line">    total_x = <span class="built_in">sum</span>(x[i]*lcm_y/y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)))</span><br><span class="line">    gcd_xy = <span class="built_in">abs</span>(gcd(lcm_y,total_x))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%d/%d&#x27;</span>%(total_x/gcd_xy,lcm_y/gcd_xy)</span><br></pre></td></tr></table></figure></div>
<h4 id="365-水壶问题"><a href="#365-水壶问题" class="headerlink" title="[365] 水壶问题"></a>[365] 水壶问题</h4><ul>
<li>问题：有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</li>
<li>思路：等价于ax+by=z有整数解(a,b)，且z &lt;= x+y</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span>(<span class="params">self, x, y, z</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">m,n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> m:</span><br><span class="line">            m,n = n%m,m</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    g  = gcd(x,y)    </span><br><span class="line">    <span class="keyword">return</span> z % g == <span class="number">0</span> <span class="keyword">and</span> z &lt;= x + y <span class="keyword">if</span> g <span class="keyword">else</span> <span class="keyword">not</span> z</span><br></pre></td></tr></table></figure></div>
<h4 id="寻找-n-以内的素数"><a href="#寻找-n-以内的素数" class="headerlink" title="寻找 n 以内的素数"></a>寻找 n 以内的素数</h4><p>一般有”试除法“和”筛法“两种思路来寻找n以内的素数，这里介绍三种常用的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">思路</th>
<th style="text-align:left">空间</th>
<th style="text-align:left">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">优化试除法</td>
<td style="text-align:left">对[2,n]中的每一个数k，试除[2,sqrt(k)]中所有素数，如果能整除说明k不是素数</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(nlgn)</td>
</tr>
<tr>
<td style="text-align:left">埃拉托斯特尼筛法</td>
<td style="text-align:left">假设所有数都是素数，然后[2,sqrt(n)]间的素数p，将[p*p::p]的整数标记为非素数</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(nlglgn)</td>
</tr>
<tr>
<td style="text-align:left">线性筛法</td>
<td style="text-align:left">每个合数都能唯一分解为最小素因子和一个小于自己的数之积，只用合数的最小素因子筛将其筛去，避免重复的筛选</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="204-计算质数"><a href="#204-计算质数" class="headerlink" title="[204] 计算质数"></a>[204] 计算质数</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 试除法：4684 ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = [<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">3</span>,n):</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            tmp = <span class="built_in">int</span>(k**<span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">while</span> res[i] &lt;= tmp:</span><br><span class="line">                <span class="keyword">if</span> k % res[i]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(k)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 埃氏筛法：176ms，接近线性时间复杂度，实际效果竟然比线性筛还好</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    filt = [<span class="number">1</span>] * n</span><br><span class="line">    filt[<span class="number">0</span>] = filt[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>,<span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> filt[i]:</span><br><span class="line">            filt[i*i::i] = [<span class="number">0</span>] * ((n-<span class="number">1</span>-i*i)/i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(filt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 线性筛: 924ms </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    prime = []</span><br><span class="line">    filt = [<span class="number">1</span>] * n</span><br><span class="line">    filt[<span class="number">0</span>] = filt[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>,n):</span><br><span class="line">        <span class="keyword">if</span> filt[i]:</span><br><span class="line">            prime.append(i)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prime:</span><br><span class="line">            <span class="keyword">if</span> i * p &gt; n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            filt[i*p] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 如果i能被p整除，则i*后续素数的合数只能被p筛去</span></span><br><span class="line">            <span class="keyword">if</span> i % p == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(filt)      </span><br></pre></td></tr></table></figure></div>
<p>扩展：以上思路很容易用来求解一个整数是否为素数、整数因式分解等问题。</p>
<h3 id="算术基本定理"><a href="#算术基本定理" class="headerlink" title="算术基本定理"></a>算术基本定理</h3><p>每一个正整数都能唯一地表示为<strong>素数幂积</strong>的形式，p代表所有可能的素数：</p>
<script type="math/tex; mode=display">
n=\prod_{p}p^{n_p},\ n_p\geqslant 0</script><h4 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="[313] 超级丑数"></a>[313] 超级丑数</h4><ul>
<li>问题：编写一段程序来查找第 n 个超级丑数。超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 12, primes = [2,7,13,19]</span><br><span class="line">输出: 32 </span><br><span class="line">解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">后续丑数必然是由已有丑数与质数列表中的质数乘积的结果，为了实现有序输出，可进行k路归并，丑数排序可以看做是k个有序表的归并排序</span><br><span class="line">2*1，2*2，2*4，2*7...</span><br><span class="line">7*1，7*2，7*4，7*7...</span><br><span class="line">...</span><br><span class="line">可以用k个指针指示每个有序表当前元素的下标，将较小的值放入总表，同时如果有序表中的值等于总表的值，下标要加1</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n, primes</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :type primes: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    k = <span class="built_in">len</span>(primes)</span><br><span class="line">    index = [<span class="number">0</span>] * k</span><br><span class="line">    ugly = [<span class="number">1</span>]</span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; n:</span><br><span class="line">        cur = <span class="built_in">min</span>(ugly[index[i]] * primes[i] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k))</span><br><span class="line">        ugly.append(cur)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            <span class="keyword">if</span> ugly[index[i]] * primes[i] == cur:</span><br><span class="line">                index[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ugly[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div>
<ul>
<li>分析：时间复杂度O(kn)</li>
</ul>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>定义模运算：n模m表示n除以m所得余数，记做$n\ mod\ m$或$n\%m$</p>
<script type="math/tex; mode=display">
n\ mod\ m = n - \left \lfloor \frac{n}{m} \right \rfloor m</script><ul>
<li>模：mod后面的数称为模，至今还没有人给mod前面的数取名</li>
<li>余数：取模的结果，余数总是处于0和模之间</li>
<li>模运算可以推广到任意实数</li>
</ul>
<h3 id="模运算性质"><a href="#模运算性质" class="headerlink" title="模运算性质"></a>模运算性质</h3><p>mod运算的性质：以下性质都可以通过取模运算的定义来证明</p>
<ul>
<li>四则运算法则：<ul>
<li>$(a+b)\%c=(a\%c+b\%c)\%c$</li>
<li>$(a-b)\%c=(a\%c-b\%c)\%c$</li>
<li>$(a<em>b)\%c=(a\%c</em>b)\%c=(a\%c*b\%c)\%c$</li>
<li>$(a^b)\%c=((a\%c)^b)\%c$</li>
<li>$\frac{a}{b}\%c = a\bar{b}\%c,\ if\ b \mid a, b\perp c$</li>
</ul>
</li>
<li>分配律：$c(a\%b)=(ca)\%(cb)$，是mod运算最重要的代数性质</li>
<li>模模律：$a\%c\%c=a\%c$</li>
</ul>
<h4 id="523-连续子数组和为k的倍数"><a href="#523-连续子数组和为k的倍数" class="headerlink" title="[523] 连续子数组和为k的倍数"></a>[523] 连续子数组和为k的倍数</h4><ul>
<li>问题：给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [23,2,6,4,7], k = 6</span><br><span class="line">输出: True</span><br><span class="line">解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：(a-b)%m=a%m-b%m，连续数组的和是k的倍数在k!=0时等价于能被k整除，等价于余数为0，等价于前i项和前j项和对k的模相等。记录模m第一次出现的位置，下次出现与首次出现隔了1个元素以上则返回True，初始没有元素设模为0，下标为-1.</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    d = &#123;<span class="number">0</span>:-<span class="number">1</span>&#125;</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        total += num</span><br><span class="line">        tmp = total % (k <span class="keyword">or</span> total+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">in</span> d:</span><br><span class="line">            <span class="keyword">if</span> i &gt; d[tmp] + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[tmp] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div>
<h3 id="大数取模"><a href="#大数取模" class="headerlink" title="大数取模"></a>大数取模</h3><h4 id="一般大数取模"><a href="#一般大数取模" class="headerlink" title="一般大数取模"></a>一般大数取模</h4><p>对于某个大数，我们可以用字符串$s=a_1a_2…a_n$来存储，设f(n)代表前n个字符所组成的数值，则有:</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
\begin{align*} 
&f(n)=10f(n-1)+a_n\\
&f(1)=a_1 
\end{align*}
\end{matrix}\right.</script><p>利用取模四则运算法则来模拟手算竖式的方法:</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
\begin{align*} 
&f(n)\% m=(f(n-1)\% m \times 10+a_n)\%m\\
&f(1)\%m=a_1 \%m
\end{align*}
\end{matrix}\right.</script><p>代码:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mod</span>(<span class="params">s,m</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        res = (res%m * <span class="number">10</span> + <span class="built_in">int</span>(c))%m</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<h4 id="快速幂模"><a href="#快速幂模" class="headerlink" title="快速幂模"></a>快速幂模</h4><ul>
<li>蒙哥马利(Montgomery)幂模运算是快速计算a^b%k的一种算法，是RSA加密算法的核心之一。设$f(c,e,n)=c^e\%n$，则有以下递推式：</li>
</ul>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
\begin{align*} 
&f(c,e,n)=f(c,e-1,n)*c\%n=f(c^2\%n,e>>1,n)*c\%n,\ if\ e\&1=1\\
&f(c,e,n)=f(c^2\%n,e>>1,n),\ else
\end{align*}
\end{matrix}\right.</script><p>代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度为lge</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_mod</span>(<span class="params">base,exp,mod</span>):</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> exp:</span><br><span class="line">        <span class="keyword">if</span> exp &amp; <span class="number">1</span>:</span><br><span class="line">            res = res * base % mod</span><br><span class="line">        base, exp = base * base % mod, exp &gt;&gt; <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 递归更简洁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_mod</span>(<span class="params">base,exp,mod</span>):</span></span><br><span class="line">    <span class="keyword">if</span> exp == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>%mod</span><br><span class="line">    <span class="keyword">return</span> (Montgomery1(base*base%mod,exp&gt;&gt;<span class="number">1</span>,mod)*[<span class="number">1</span>,base%mod][exp&amp;<span class="number">1</span>])%mod</span><br></pre></td></tr></table></figure></div>
<h4 id="372-超级次方——幂模"><a href="#372-超级次方——幂模" class="headerlink" title="[372] 超级次方——幂模"></a>[372] 超级次方——幂模</h4><ul>
<li>问题：你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。</li>
<li>思路：快速取模,取模的乘法法则(a<em>b)%m=(a%m</em>b%m)%m，f(a,b0+b1<em>10+…) = (a^b0%m </em> f(a^10,b1+b2*10+…))%m</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superPow</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type a: int</span></span><br><span class="line"><span class="string">    :type b: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    base = a</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> b[::-<span class="number">1</span>]:</span><br><span class="line">        res = (res * self.quick_mod(base,n,<span class="number">1337</span>)) % <span class="number">1337</span></span><br><span class="line">        base = self.quick_mod(base,<span class="number">10</span>,<span class="number">1337</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_mod</span>(<span class="params">self,base,exp,mod</span>):</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> exp:</span><br><span class="line">        <span class="keyword">if</span> exp &amp; <span class="number">1</span>:</span><br><span class="line">            res = res * base % mod</span><br><span class="line">        base = base * base % mod</span><br><span class="line">        exp &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<h2 id="其他数论问题"><a href="#其他数论问题" class="headerlink" title="其他数论问题"></a>其他数论问题</h2><h4 id="勾股素数"><a href="#勾股素数" class="headerlink" title="勾股素数"></a>勾股素数</h4><ul>
<li>问题：找到&lt;=n的素勾股数 和 不能构成勾股数的边的长度个数。如果 (a, b, c) 是勾股数，它们的正整数倍数，也是勾股数，即 (na, nb, nc) 也是勾股数。若果 a, b, c 三者互质（它们的最大公因数是 1），它们就称为素勾股数。</li>
<li>思路：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以下的方法可用来找出勾股数。设 m &gt; n 、 m 和 n 均是正整数，</span><br><span class="line"></span><br><span class="line">a = m2 − n2,</span><br><span class="line">b = 2mn,</span><br><span class="line">c = m2 + n2</span><br><span class="line">若 m 和 n 是互质，而且 m 和 n 其中有一个是偶数，计算出来的 a, b, c 就是素勾股数。（若 m 和 n 都是奇数， a, b, c 就会全是偶数，不符合互质。）</span><br><span class="line"></span><br><span class="line">所有素勾股数可用上述列式当中找出，这亦可推论到数学上存在无穷多的素勾股数。</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool vis[1000010];</span><br><span class="line"></span><br><span class="line">int gcd(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    return y==0?x:gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = 0,num = 0;</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        for(int i=1;i&lt;=sqrt(n);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=i+1;j&lt;=sqrt(n);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                int x = j*j-i*i;</span><br><span class="line">                int y = 2*i*j;</span><br><span class="line">                int z = i*i+j*j;</span><br><span class="line"></span><br><span class="line">                if(x&lt;=n &amp;&amp; y&lt;=n &amp;&amp; z&lt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(!vis[x]) vis[x] = true,cnt++;</span><br><span class="line">                    if(!vis[y]) vis[y] = true,cnt++;</span><br><span class="line">                    if(!vis[z]) vis[z] = true,cnt++;</span><br><span class="line">                    int f = n/z;</span><br><span class="line">                    for(int k=1;k&lt;=f;k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        int nx = x*k,ny = y*k,nz = z*k;</span><br><span class="line">                        if(!vis[nx]) vis[nx] = true,cnt++;</span><br><span class="line">                        if(!vis[ny]) vis[ny] = true,cnt++;</span><br><span class="line">                        if(!vis[nz]) vis[nz] = true,cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(gcd(i,j)==1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if(((i&amp;1) &amp;&amp; (j&amp;1)==0) || ((j&amp;1) &amp;&amp; (i&amp;1)==0))</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %d\n&quot;,num,n-cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="整数-序列转化"><a href="#整数-序列转化" class="headerlink" title="整数-序列转化"></a>整数-序列转化</h4><p>这可能是最常用的操作了</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">n2s</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将整数n转化为字符串&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        div,mod = <span class="built_in">divmod</span>(n,<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">        res = <span class="built_in">str</span>(mod) + res</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s2n</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将字符串转化为整数&quot;&quot;&quot;</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        res = res * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure></div>
<h4 id="171-Excel列名转列号"><a href="#171-Excel列名转列号" class="headerlink" title="[171] Excel列名转列号"></a>[171] Excel列名转列号</h4><ul>
<li>问题:给定一个Excel表格中的列名称，返回其相应的列序号</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：26进制转化为10进制</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    c2i = <span class="keyword">lambda</span> x:<span class="built_in">ord</span>(x)-<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)+<span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        res = res * <span class="number">26</span> + c2i(c) </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<h4 id="168-Excel列号转列名"><a href="#168-Excel列号转列名" class="headerlink" title="[168] Excel列号转列名"></a>[168] Excel列号转列名</h4><ul>
<li>问题：给定一个正整数，返回它在 Excel 表中相对应的列名称</li>
<li>思路：难点在于A表示1而不是0，Ai<em>26**i = ai</em>26^i+26^i，a0<em>26^0+26^0 + a1</em>26^1+26^1 + … + =n，(n-1)/26 = a1*26^0 + 26^0+…转化为子问题，因此n = (n-1)/26，a0 = (n-1)%26 0~25对应A~Z</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        ans = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) + (n - <span class="number">1</span>) % <span class="number">26</span>) + ans</span><br><span class="line">        n = (n - <span class="number">1</span>) / <span class="number">26</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div>
<h4 id="812-三点构成最大面积"><a href="#812-三点构成最大面积" class="headerlink" title="[812] 三点构成最大面积"></a>[812] 三点构成最大面积</h4><ul>
<li>问题:给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积</li>
<li>思路：遍历所有可能的三点组合，求出最大面积，核心在于已知三点如何求三点构成的三角形的面积，设A(x1,y1),B(x2,y2),C(x3,y3)，则三角形面积可以表示为AB与AC叉乘绝对值的一半：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          i      j</span><br><span class="line">        x2-x1, y2-y1</span><br><span class="line">AB×AC =              = (x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)</span><br><span class="line">        x3-x1, y3-y1</span><br><span class="line">S(ABC) = 0.5*abs(AB×AC)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestTriangleArea</span>(<span class="params">self, points</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type points: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">        x1,y1,x2,y2,x3,y3 = a[<span class="number">0</span>],a[<span class="number">1</span>],b[<span class="number">0</span>],b[<span class="number">1</span>],c[<span class="number">0</span>],c[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">abs</span>((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">len</span>(points)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n-<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(j+<span class="number">1</span>,n):</span><br><span class="line">                res = <span class="built_in">max</span>(res, area(points[i], points[j], points[k]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<h4 id="593-四点是否构成正方形"><a href="#593-四点是否构成正方形" class="headerlink" title="[593] 四点是否构成正方形"></a>[593] 四点是否构成正方形</h4><ul>
<li>问题：给定二维空间中四点的坐标，返回四点是否可以构造一个正方形</li>
<li>思路:正方形充要条件：四条边相等，对角线相等&gt;0;识别对角点的方法：如果是正方形，则排序后，第一个点代表左下点，最后一个点代表右上点，它们必是对角顶点</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validSquare</span>(<span class="params">self, p1, p2, p3, p4</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type p1: List[int]</span></span><br><span class="line"><span class="string">    :type p2: List[int]</span></span><br><span class="line"><span class="string">    :type p3: List[int]</span></span><br><span class="line"><span class="string">    :type p4: List[int]</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dis = <span class="keyword">lambda</span> x,y:(x[<span class="number">0</span>]-y[<span class="number">0</span>])**<span class="number">2</span> + (x[<span class="number">1</span>]-y[<span class="number">1</span>])**<span class="number">2</span></span><br><span class="line">    p = [p1,p2,p3,p4]</span><br><span class="line">    p.sort()</span><br><span class="line">    <span class="keyword">if</span> dis(p[<span class="number">0</span>],p[<span class="number">1</span>]) == dis(p[<span class="number">0</span>],p[<span class="number">2</span>]) == dis(p[<span class="number">3</span>],p[<span class="number">1</span>]) == dis(p[<span class="number">3</span>],p[<span class="number">2</span>]) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> dis(p[<span class="number">0</span>],p[<span class="number">3</span>]) == dis(p[<span class="number">1</span>],p[<span class="number">2</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div>
<h4 id="223-矩形面积"><a href="#223-矩形面积" class="headerlink" title="[223] 矩形面积"></a>[223] 矩形面积</h4><ul>
<li>问题:在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。每个矩形由其左下顶点和右上顶点坐标表示，如图所示。</li>
</ul>
<div align=center>
    <img src="https://likeitea-1257692904.cos.ap-guangzhou.myqcloud.com/liketea_blog/17-18-37.png" width="50%" heigh="50%"></img>
</div>

<ul>
<li>思路:转化为求交集的面积sum() = max(0,min(D,H)-max(B,F)) * max(0,min(C,G)-max(A,E))</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeArea</span>(<span class="params">self, A, B, C, D, E, F, G, H</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: int</span></span><br><span class="line"><span class="string">        :type B: int</span></span><br><span class="line"><span class="string">        :type C: int</span></span><br><span class="line"><span class="string">        :type D: int</span></span><br><span class="line"><span class="string">        :type E: int</span></span><br><span class="line"><span class="string">        :type F: int</span></span><br><span class="line"><span class="string">        :type G: int</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total = (D-B) * (C-A) + (G-E) * (H-F)</span><br><span class="line">        <span class="keyword">return</span> total - <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">min</span>(D,H)-<span class="built_in">max</span>(B,F)) * <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">min</span>(C,G)-<span class="built_in">max</span>(A,E))</span><br></pre></td></tr></table></figure></div>
<h4 id="453-最小移动次数使数组元素相等"><a href="#453-最小移动次数使数组元素相等" class="headerlink" title="[453] 最小移动次数使数组元素相等"></a>[453] 最小移动次数使数组元素相等</h4><ul>
<li>问题:给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">只需要3次移动（注意每次移动会增加两个元素的值）：</span><br><span class="line"></span><br><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：：一次移动将n - 1个元素加1，等价于将剩下的1个元素减1。因此累加数组中各元素与最小值之差即可</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(nums) - <span class="built_in">min</span>(nums) * <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure></div>
<h4 id="462-最少移动次数使数组元素相等-II"><a href="#462-最少移动次数使数组元素相等-II" class="headerlink" title="[462] 最少移动次数使数组元素相等 II"></a>[462] 最少移动次数使数组元素相等 II</h4><ul>
<li>问题：给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[1,2,3]</span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line">说明：</span><br><span class="line">只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： </span><br><span class="line">[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：中位数定理：当a取x中的中位数时，绝对残差和sum(|x-a|)最小</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        median = self.findKthLargest(nums,<span class="number">0</span>,n-<span class="number">1</span>,(n-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">abs</span>(num-median) <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, l, r, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        pivot = self.partition(nums,l,r)</span><br><span class="line">        <span class="keyword">if</span> pivot == k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[pivot]</span><br><span class="line">        <span class="keyword">elif</span> pivot &lt; k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthLargest(nums, pivot+<span class="number">1</span>, r, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthLargest(nums, l, pivot-<span class="number">1</span>, k)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,low,high</span>):</span></span><br><span class="line">        rand = random.randint(low,high)</span><br><span class="line">        nums[rand],nums[low] = nums[low],nums[rand]</span><br><span class="line">        </span><br><span class="line">        bag = low</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low+<span class="number">1</span>,high+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= nums[low]:</span><br><span class="line">                bag += <span class="number">1</span></span><br><span class="line">                nums[bag],nums[i] = nums[i], nums[bag]</span><br><span class="line">        nums[bag], nums[low] = nums[low],nums[bag]</span><br><span class="line">        <span class="keyword">return</span> bag</span><br></pre></td></tr></table></figure></div>
<h4 id="517-超级洗衣机——均衡"><a href="#517-超级洗衣机——均衡" class="headerlink" title="[517] 超级洗衣机——均衡"></a>[517] 超级洗衣机——均衡</h4><ul>
<li>问题:假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n） 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数。如果不能使每台洗衣机中衣物的数量相等，则返回 -1。</li>
<li>思路:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">讨论每个元素处的情形，记l,r代表i元素左右两侧和超出平均水平的值，讨论三种情形：</span><br><span class="line">        1. l &gt;=0,r&gt;=0，两边一定会流向i，可同时进行，需要次数max(l,r)</span><br><span class="line">        2. l &lt; 0,r &lt; 0,i一定会流向两边，不可同时进行，需要次数-l-r</span><br><span class="line">        3. 其他情形流经i的元素需要有max(abs(l),abs(r))次流动</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinMoves</span>(<span class="params">self, machines</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type machines: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(machines)</span><br><span class="line">    total = <span class="built_in">sum</span>(machines)</span><br><span class="line">    <span class="keyword">if</span> total % n:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    avg = total/n</span><br><span class="line">    l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(machines):</span><br><span class="line">        r += avg - num</span><br><span class="line">        <span class="keyword">if</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &gt;= <span class="number">0</span>:</span><br><span class="line">            res = <span class="built_in">max</span>(res,<span class="built_in">max</span>(l,r))</span><br><span class="line">        <span class="keyword">elif</span> l &lt; <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="number">0</span>:</span><br><span class="line">            res = <span class="built_in">max</span>(res,<span class="built_in">abs</span>(l)+<span class="built_in">abs</span>(r))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="built_in">max</span>(res,<span class="built_in">abs</span>(l),<span class="built_in">abs</span>(r))</span><br><span class="line">        l += num - avg</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<h4 id="319-灯泡开关"><a href="#319-灯泡开关" class="headerlink" title="[319] 灯泡开关"></a>[319] 灯泡开关</h4><ul>
<li>问题：初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。</li>
<li>思路：对于第i个灯泡，当i的因子个数为奇数时，最终会保持点亮状态，例如9的因子为1，3，9，当且仅当i为完全平方数时，其因子个数为奇数，另外1~n中完全平方数的个数为n**0.5</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulbSwitch</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(n**<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></div>
<h4 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="[172] 阶乘后的零"></a>[172] 阶乘后的零</h4><ul>
<li>问题：给定一个整数 n，返回 n! 结果尾数中零的数量</li>
<li>思路：n!后缀0的个数 = n!质因子中5的个数 = floor(n/5) + floor(n/25) + floor(n/125) + ….</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += n/<span class="number">5</span></span><br><span class="line">        n = n/<span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="[343] 整数拆分"></a>[343] 整数拆分</h4><ul>
<li>问题:给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。例如，给定 n = 2，返回1（2 = 1 + 1）；给定 n = 10，返回36（10 = 3 + 3 + 4）。注意：你可以假设 n 不小于2且不大于58。</li>
<li>思路：向下分解到3就不能再分了<ul>
<li>如果刚好，返回3**(n/2)</li>
<li>如果余1，就把1加到3上构成4</li>
<li>如果余2，乘2</li>
</ul>
</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    mod = n % <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> mod == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> ** (n/<span class="number">3</span>) <span class="keyword">if</span> n &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> mod == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> ** (n/<span class="number">3</span>-<span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> ** (n/<span class="number">3</span>) * <span class="number">2</span> <span class="keyword">if</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<h4 id="279-完全平方数——四平方和定理"><a href="#279-完全平方数——四平方和定理" class="headerlink" title="[279] 完全平方数——四平方和定理"></a>[279] 完全平方数——四平方和定理</h4><ul>
<li>问题：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 = 4 + 9.</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路1：动态规划，状态转移方程dp[n] = min(dp[n-i^2]) + 1,if n不是完全平方数，如果是完全平方数返回1，时间复杂度O(n * sqrt n)；</li>
<li>思路2：四平方和定理：任何自然数都可以用最多四个平方和数之和，且只有当$n=4^a<em>(8</em>b+7)$时才需要最少四个平方数之和；</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(n**<span class="number">0.5</span>)**<span class="number">2</span> == n:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    lst = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>)]</span><br><span class="line">    Q = <span class="built_in">set</span>(lst)</span><br><span class="line">    <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> Q:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">        Q = <span class="built_in">set</span>(q+x <span class="keyword">for</span> q <span class="keyword">in</span> Q <span class="keyword">for</span> x <span class="keyword">in</span> lst <span class="keyword">if</span> q+x&lt;=n)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路2:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &amp; <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        n &gt;&gt;= <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">7</span> == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> xrange(<span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        b = <span class="built_in">int</span>((n - a * a)**<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">if</span> a * a + b * b == n:</span><br><span class="line">            <span class="keyword">return</span> (a != <span class="number">0</span>) + (b!=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div>
<h4 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="[368] 最大整除子集"></a>[368] 最大整除子集</h4><ul>
<li>问题：给出一个由无重复的正整数组成的集合, 找出其中最大的整除子集, 子集中任意一对 (Si, Sj) 都要满足: Si % Sj = 0 或 Sj % Si = 0。如果有多个目标子集，返回其中任何一个均可</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">集合: [1,2,3]</span><br><span class="line">结果: [1,2] (当然, [1,3] 也正确)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：动态规划，dp[x] = max(dp[x], dp[y] + 1)  其中： 0 &lt;= y &lt; x 且 nums[x] % nums[y] == 0记录最大路径，只需每次转移时，记录x的父节点，最后即可从最大DP处追溯到整条最大的路径</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    nums.sort()</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp =[<span class="number">1</span>] * n</span><br><span class="line">    pre = [<span class="literal">None</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] % nums[j] == <span class="number">0</span> <span class="keyword">and</span> dp[j] + <span class="number">1</span> &gt; dp[i]:</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                pre[i] = j</span><br><span class="line">    start = dp.index(<span class="built_in">max</span>(dp))</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> start <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        res.append(nums[start])</span><br><span class="line">        start = pre[start]</span><br><span class="line">    <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div>
<h4 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="[670] 最大交换"></a>[670] 最大交换</h4><ul>
<li>问题：给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2736</span><br><span class="line">输出: 7236</span><br><span class="line">解释: 交换数字2和数字7。</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：从后向前，记录当前后缀中最大元素的位置，相等算后面的；从前向后，如果当前位置元素小于后续最大元素，则交换二者；</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSwap</span>(<span class="params">self, num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">str</span>(num))</span><br><span class="line">    n = <span class="built_in">len</span>(num)</span><br><span class="line">    </span><br><span class="line">    max_id = <span class="built_in">range</span>(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num[i] &lt;= num[max_id[i+<span class="number">1</span>]]:</span><br><span class="line">            max_id[i] = max_id[i+<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">        <span class="keyword">if</span> num[j] &lt; num[max_id[j]]:</span><br><span class="line">            num[j],num[max_id[j]] = num[max_id[j]],num[j]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,num)))</span><br></pre></td></tr></table></figure></div>
<h4 id="754-到达终点数字"><a href="#754-到达终点数字" class="headerlink" title="[754] 到达终点数字"></a>[754] 到达终点数字</h4><ul>
<li>问题:在一根无限长的数轴上，你站在0的位置。终点在target的位置。每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。返回到达终点需要的最小移动次数。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: target = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">第一次移动，从 0 到 1 。</span><br><span class="line">第二次移动，从 1 到 -1 。</span><br><span class="line">第三次移动，从 -1 到 2 。</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分情况讨论：</span><br><span class="line">    1. 1+2+。。。+k=target，则返回k</span><br><span class="line">    2. 1+2+...+k刚好大于target，如果多出d为偶数，则只需将d/2反向即可，返回k</span><br><span class="line">    3. 如果d为奇数，任何数的反向都只会改变偶数次，k次达不到，这时+k+1差距如果是偶数，返回k+1，</span><br><span class="line">    4. 如果是奇数,返回k+2，因为必能在k次达到target-1，再经过两次+k-(k+1)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reachNumber</span>(<span class="params">self, target</span>):</span></span><br><span class="line">    n = <span class="built_in">abs</span>(target)</span><br><span class="line">    <span class="comment"># 解二次方程</span></span><br><span class="line">    k = <span class="built_in">int</span>(math.ceil(((<span class="number">8</span>*n+<span class="number">1</span>)**<span class="number">0.5</span>-<span class="number">1</span>)/<span class="number">2.</span>))</span><br><span class="line">    total = k*(k+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">    d = total - n</span><br><span class="line">    <span class="keyword">if</span> d % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> k</span><br><span class="line">    <span class="keyword">elif</span> (d+k+<span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> k + <span class="number">2</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>分析：时间复杂度O(1)</li>
</ul>
<h4 id="50-快速幂"><a href="#50-快速幂" class="headerlink" title="[50] 快速幂"></a>[50] 快速幂</h4><ul>
<li>问题：实现 pow(x, n) ，即计算 x 的 n 次幂函数</li>
<li>思路:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">快速计算幂：时间复杂度lgn</span><br><span class="line">    1. x^n = (x^2)^(n&gt;&gt;2),if n &amp; 1 == 0</span><br><span class="line">    2. x^n = (x^2)^(n&gt;&gt;2) * x,if n &amp; 1 </span><br><span class="line">    3. 边界如果是正数则n=0，负数则n=-1</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: float</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.</span></span><br><span class="line">    <span class="keyword">if</span> n == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.</span>/x</span><br><span class="line">    <span class="keyword">return</span> self.myPow(x*x, n&gt;&gt;<span class="number">1</span>)*[<span class="number">1</span>,x][n&amp;<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div>
<h4 id="829-连续整数求和"><a href="#829-连续整数求和" class="headerlink" title="[829] 连续整数求和"></a>[829] 连续整数求和</h4><ul>
<li>问题:给定一个正整数 N，试求有多少组连续正整数满足所有数字之和为 N?</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: 3</span><br><span class="line">解释: 9 = 9 = 4 + 5 = 2 + 3 + 4</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路2：假设连续数组长度为c，那么和为N的数组满足：</span><br><span class="line">    1. 如果c为奇数，N/c为整数</span><br><span class="line">    2. 如果c为偶数，(N/c+0.5)*c=N</span><br><span class="line">    同时，要求为正整数，如果c(c+1)/2&gt;N，break</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consecutiveNumbersSum</span>(<span class="params">self, N</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type N: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> c &lt;= N:</span><br><span class="line">        <span class="keyword">if</span> c*(c+<span class="number">1</span>)/<span class="number">2</span> &gt; N:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> c &amp; <span class="number">1</span>:</span><br><span class="line">            res += N % c == <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += N / c * c + c / <span class="number">2</span> == N</span><br><span class="line">        c += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<h4 id="400-第N个数字"><a href="#400-第N个数字" class="headerlink" title="[400] 第N个数字"></a>[400] 第N个数字</h4><ul>
<li>问题：在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11</span><br><span class="line">输出:</span><br><span class="line">0</span><br><span class="line">说明:</span><br><span class="line">第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1   1-9</span><br><span class="line">2   10-99</span><br><span class="line">3   100-999</span><br><span class="line">4   1000-9999</span><br><span class="line">5   10000-99999</span><br><span class="line">6   100000-999999</span><br><span class="line">7   1000000-9999999</span><br><span class="line">8   10000000-99999999</span><br><span class="line">9   100000000-99999999</span><br><span class="line">先确定所属段，再确定所属整数，再确定对应字符</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line">        delta = <span class="number">9</span> * <span class="number">10</span> ** i</span><br><span class="line">        <span class="keyword">if</span> n &lt;= delta * (i+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n -= delta * (i+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    number = <span class="built_in">str</span>((n - <span class="number">1</span>) / (i + <span class="number">1</span>) + <span class="number">10</span> ** i)</span><br><span class="line">    index  = (n - <span class="number">1</span>) % (i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(number[index])</span><br></pre></td></tr></table></figure></div>
<h4 id="233-数字1的个数"><a href="#233-数字1的个数" class="headerlink" title="[233] 数字1的个数"></a>[233] 数字1的个数</h4><ul>
<li>问题：给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</li>
<li>思路:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分类讨论1在各个位上出现的次数：if n = xyzdabc，现讨论千位上的1出现的次数</span><br><span class="line">    (1) xyz * 1000                     if d == 0  xy(z-1)1000~xy(z-1)1999:1000~1999</span><br><span class="line">    (2) xyz * 1000 + abc + 1           if d == 1  xyz1000~xyz1abc</span><br><span class="line">    (3) xyz * 1000 + 1000              if d &gt; 1   xyz1000~xyz1999</span><br><span class="line">对每一位上1出现的次数加和即可</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">str</span>(n)</span><br><span class="line">    k = <span class="built_in">len</span>(n)</span><br><span class="line">    <span class="keyword">for</span> i,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(n):</span><br><span class="line">        left  = <span class="built_in">int</span>(n[:i] <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line">        mid   = <span class="built_in">int</span>(n[i])</span><br><span class="line">        right = <span class="built_in">int</span>(n[i+<span class="number">1</span>:] <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line">        cur = <span class="number">10</span> ** (k-i-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> mid == <span class="number">0</span>:</span><br><span class="line">            res += left * cur</span><br><span class="line">        <span class="keyword">elif</span> mid == <span class="number">1</span>:</span><br><span class="line">            res += left * cur + right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += left * cur + cur</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div>
<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="[43] 字符串相乘"></a>[43] 字符串相乘</h4><ul>
<li>问题: 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p>思路: 模拟手动乘法，从后向前，div,mod=divmod(xi*yj,10)，mod存放在数组res的i+j位，div存放在i+j+1位，最后从后向前遍历res，div,mod=divmod(res[i],10)，mod留到i位，div加到i+1位，结束时如果div不为0则创建新的位来存</p>
</li>
<li><p>代码:</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num1: str</span></span><br><span class="line"><span class="string">    :type num2: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(num1),<span class="built_in">len</span>(num2)</span><br><span class="line">    res =[<span class="number">0</span>] * (m + n)</span><br><span class="line">    num1,num2 = num1[::-<span class="number">1</span>],num2[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">            div,mod = <span class="built_in">divmod</span>(<span class="built_in">int</span>(num1[i])*<span class="built_in">int</span>(num2[j]),<span class="number">10</span>)</span><br><span class="line">            res[i+j] += mod</span><br><span class="line">            res[i+j+<span class="number">1</span>] += div</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> xrange(m+n-<span class="number">1</span>):</span><br><span class="line">        div,mod = <span class="built_in">divmod</span>(res[k], <span class="number">10</span>)</span><br><span class="line">        res[k] = mod</span><br><span class="line">        res[k+<span class="number">1</span>] += div</span><br><span class="line">    </span><br><span class="line">    count = m + n</span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">1</span> <span class="keyword">and</span> res[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        res.pop()</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,res[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></div>
<h4 id="不使用乘除的除法"><a href="#不使用乘除的除法" class="headerlink" title="不使用乘除的除法"></a>不使用乘除的除法</h4><ul>
<li>问题：给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3</span><br><span class="line">输出: -2</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路：a/b=c，则：a = b<em>c + m=(b</em>2^k1 + b <em> 2^k2 + …b</em>2^0 + m)，尝试用被除数减y的2<strong>31…2</strong>0倍数，如果减得动则把相应的倍数加到商中，如果减不动则尝试更小的倍数</li>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span>(<span class="params">self, dividend, divisor</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type dividend: int</span></span><br><span class="line"><span class="string">    :type divisor: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mark = (dividend &gt;= <span class="number">0</span>) == (divisor &gt;= <span class="number">0</span>)</span><br><span class="line">    x, y = <span class="built_in">map</span>(<span class="built_in">abs</span>,[dividend, divisor])</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">31</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> x &gt;&gt; i &gt;= y:</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">            x -= y &lt;&lt; i</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>,res) <span class="keyword">if</span> mark <span class="keyword">else</span> <span class="built_in">max</span>(-<span class="number">2</span>**<span class="number">31</span>,-res)</span><br></pre></td></tr></table></figure></div>
<h4 id="166-分数到小数"><a href="#166-分数到小数" class="headerlink" title="[166] 分数到小数"></a>[166] 分数到小数</h4><ul>
<li>问题：给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。如果小数部分为循环小数，则将循环的部分括在括号内。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numerator = 2, denominator = 3</span><br><span class="line">输出: &quot;0.(6)&quot;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路：模拟手除法</span><br><span class="line">    1. 首先算出整数部分n/m和余数部分n%m，如果n和m有负号，将符号单独拿出</span><br><span class="line">    2. 余数不为零，或者不在余数字典&#123;余数:最后出现的位置&#125;中，则将余数放在余数字典，同时余数*10再除被除数，记录值和新的余数</span><br><span class="line">    3. 如果余数为0，则将当前的整数和小数部分组合</span><br><span class="line">    4. 如果余数不为0，则将当前整数和小数部分组合，同时找到当前余数上次出现的位置，加上括号</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fractionToDecimal</span>(<span class="params">self, numerator, denominator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type numerator: int</span></span><br><span class="line"><span class="string">    :type denominator: int</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    flag = <span class="string">&#x27;-&#x27;</span> * (numerator ^ denominator &lt; <span class="number">0</span> <span class="keyword">and</span> numerator != <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    n,m = <span class="built_in">abs</span>(numerator), <span class="built_in">abs</span>(denominator)</span><br><span class="line">    inter = n/m</span><br><span class="line">    n = n% m</span><br><span class="line">    </span><br><span class="line">    mod = &#123;&#125;</span><br><span class="line">    dec = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> mod:</span><br><span class="line">        mod[n] = index</span><br><span class="line">        n *= <span class="number">10</span></span><br><span class="line">        dec.append(n/m)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        n %= m</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> dec:</span><br><span class="line">            decimal = <span class="string">&#x27;.%s&#x27;</span>%(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,dec)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            decimal = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        decimal = <span class="string">&#x27;.%s(%s)&#x27;</span>%(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,dec[:mod[n]])),<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,dec[mod[n]:index])))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s%d%s&#x27;</span>%(flag, inter, decimal)</span><br></pre></td></tr></table></figure></div>
<h4 id="149-直线上最多的点数——按起点分类"><a href="#149-直线上最多的点数——按起点分类" class="headerlink" title="[149] 直线上最多的点数——按起点分类"></a>[149] 直线上最多的点数——按起点分类</h4><ul>
<li>问题：给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">|  o</span><br><span class="line">|     o        o</span><br><span class="line">|        o</span><br><span class="line">|  o        o</span><br><span class="line">+-------------------&gt;</span><br><span class="line">0  1  2  3  4  5  6</span><br></pre></td></tr></table></figure></div>
<ul>
<li>思路1：对于每个点统计其他点到它的斜率出现的次数，次数最大的斜率，对应共线点数最多的直线；需注意如果横坐标相同时记斜率为None；可能含有重复的点，重复的点可以算作任何斜率</li>
<li>思路2：RANSAC (Random sample consensus)算法，每次随机抽出一对点，找到所有和他们共线的点数，只需要重复几十次抽样就可以得到正确结果（但不保证每次都能成功）</li>
<li>代码：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路1:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type points: List[Point]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slope</span>(<span class="params">point1,point2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> point1.x == point2.x:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100.</span>*(point2.y - point1.y)/(point2.x-point1.x)</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">len</span>(points)</span><br><span class="line">    res = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">        d = collections.Counter()</span><br><span class="line">        same = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>,n):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> points[i].x == points[j].x <span class="keyword">and</span> points[i].y == points[j].y:</span><br><span class="line">                same += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[slope(points[i],points[j])] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            res = <span class="built_in">max</span>(res, d.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">1</span>] + same)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="built_in">max</span>(res, same)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type points: List[Point]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pairs</span>():</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            index1, index2 = random.sample(xrange(n), <span class="number">2</span>)</span><br><span class="line">            p1,p2 = points[index1],points[index2]</span><br><span class="line">            <span class="keyword">if</span> p1.x != p2.x <span class="keyword">or</span> p1.y != p2.y:</span><br><span class="line">                <span class="keyword">return</span> p1, p2</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">len</span>(points)</span><br><span class="line">    s = &#123;(p.x, p.y) <span class="keyword">for</span> p <span class="keyword">in</span> points&#125;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange (<span class="number">0</span>,<span class="number">50</span>): </span><br><span class="line">        p1, p2 = get_pairs()</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">            p3 = points[j]</span><br><span class="line">            <span class="keyword">if</span> (p2.y-p1.y) * (p3.x-p1.x) == (p2.x-p1.x) * (p3.y-p1.y):</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, cur)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> res   </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="810-黑板异或游戏（位运算）"><a href="#810-黑板异或游戏（位运算）" class="headerlink" title="[810] 黑板异或游戏（位运算）"></a>[810] 黑板异或游戏（位运算）</h4><ul>
<li>问题：一个黑板上写着一个非负整数数组 nums[i] 。小红和小明轮流从黑板上擦掉一个数字，小红先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。假设两个玩家每步都使用最优解，当且仅当小红获胜时返回 true。</li>
<li>思路：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  bit  :      3 2 1 0</span><br><span class="line">---------------------</span><br><span class="line">num1 : 10 | 1 0 1 0 </span><br><span class="line">num2 : 11 | 1 0 1 1</span><br><span class="line">num3 : 1  | 0 0 0 1</span><br><span class="line">num4 : 2  | 0 0 1 0</span><br><span class="line">num5 : 2  | 0 0 1 0</span><br><span class="line">num6 : 8  | 1 0 0 0</span><br><span class="line">--------------------</span><br><span class="line">XOR  : 8  | 1 0 0 0</span><br><span class="line">   如果开始时xor(nums) = 0，则A赢</span><br><span class="line">   如果开始时xor(nums) !=0，如果len(nums)是偶数，则A赢，反之B赢。</span><br><span class="line">      1. A只需要先找到xor(nums)中为1的二进制位，数组中必存在该位为0的元素（否则偶数个元素的异或就变成0了），A选择移去该元素，对该位的结果无影响，xor(nums) !=0</span><br><span class="line">      2. B做选择，B随便做什么选择，A要么赢，要么回到上一轮同样的状态，偶数个元素异或不为0，选择不能无限持续下去，最终必然无论B选什么，异或结果都会变成0</span><br></pre></td></tr></table></figure></div>
<ul>
<li>代码:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xorGame</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x^y, nums) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) &amp; <span class="number">1</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="https://likeitea-1257692904.cos.ap-guangzhou.myqcloud.com/liketea_blog/wechatpay.jpg" alt=" 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%8E%A8%E8%8D%90/" rel="next" title="推荐系统（二）—— 基于用户行为推荐">
                <i class="fa fa-chevron-left"></i> 推荐系统（二）—— 基于用户行为推荐
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="prev" title="数据结构与算法：二分查找">
                数据结构与算法：二分查找 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MzE5OS8xOTc0NQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://joeschmoe.io/api/v1/random"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">117</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/liketea/blog.github.io" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:likeitea@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E9%99%A4%E6%80%A7%E4%B8%8E%E7%B4%A0%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">整除性与素数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">辗转相除法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">计算最大公约数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">计算最小公倍数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E8%B4%9D%E7%A5%96%E6%96%B9%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">求解贝祖方程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#592-%E5%88%86%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.4.</span> <span class="nav-text">[592] 分数加减运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.5.</span> <span class="nav-text">[365] 水壶问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE-n-%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0"><span class="nav-number">1.1.6.</span> <span class="nav-text">寻找 n 以内的素数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#204-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0"><span class="nav-number">1.1.7.</span> <span class="nav-text">[204] 计算质数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">算术基本定理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">[313] 超级丑数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="nav-number">2.</span> <span class="nav-text">模运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E8%BF%90%E7%AE%97%E6%80%A7%E8%B4%A8"><span class="nav-number">2.1.</span> <span class="nav-text">模运算性质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#523-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%80%8D%E6%95%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">[523] 连续子数组和为k的倍数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1"><span class="nav-number">2.2.</span> <span class="nav-text">大数取模</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1"><span class="nav-number">2.2.1.</span> <span class="nav-text">一般大数取模</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1"><span class="nav-number">2.2.2.</span> <span class="nav-text">快速幂模</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#372-%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9%E2%80%94%E2%80%94%E5%B9%82%E6%A8%A1"><span class="nav-number">2.2.3.</span> <span class="nav-text">[372] 超级次方——幂模</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E8%AE%BA%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">其他数论问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8B%BE%E8%82%A1%E7%B4%A0%E6%95%B0"><span class="nav-number">3.0.1.</span> <span class="nav-text">勾股素数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0-%E5%BA%8F%E5%88%97%E8%BD%AC%E5%8C%96"><span class="nav-number">3.0.2.</span> <span class="nav-text">整数-序列转化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#171-Excel%E5%88%97%E5%90%8D%E8%BD%AC%E5%88%97%E5%8F%B7"><span class="nav-number">3.0.3.</span> <span class="nav-text">[171] Excel列名转列号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#168-Excel%E5%88%97%E5%8F%B7%E8%BD%AC%E5%88%97%E5%90%8D"><span class="nav-number">3.0.4.</span> <span class="nav-text">[168] Excel列号转列名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#812-%E4%B8%89%E7%82%B9%E6%9E%84%E6%88%90%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">3.0.5.</span> <span class="nav-text">[812] 三点构成最大面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#593-%E5%9B%9B%E7%82%B9%E6%98%AF%E5%90%A6%E6%9E%84%E6%88%90%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">3.0.6.</span> <span class="nav-text">[593] 四点是否构成正方形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="nav-number">3.0.7.</span> <span class="nav-text">[223] 矩形面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#453-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89"><span class="nav-number">3.0.8.</span> <span class="nav-text">[453] 最小移动次数使数组元素相等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#462-%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89-II"><span class="nav-number">3.0.9.</span> <span class="nav-text">[462] 最少移动次数使数组元素相等 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#517-%E8%B6%85%E7%BA%A7%E6%B4%97%E8%A1%A3%E6%9C%BA%E2%80%94%E2%80%94%E5%9D%87%E8%A1%A1"><span class="nav-number">3.0.10.</span> <span class="nav-text">[517] 超级洗衣机——均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#319-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3"><span class="nav-number">3.0.11.</span> <span class="nav-text">[319] 灯泡开关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6"><span class="nav-number">3.0.12.</span> <span class="nav-text">[172] 阶乘后的零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="nav-number">3.0.13.</span> <span class="nav-text">[343] 整数拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E2%80%94%E2%80%94%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86"><span class="nav-number">3.0.14.</span> <span class="nav-text">[279] 完全平方数——四平方和定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86"><span class="nav-number">3.0.15.</span> <span class="nav-text">[368] 最大整除子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2"><span class="nav-number">3.0.16.</span> <span class="nav-text">[670] 最大交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#754-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%95%B0%E5%AD%97"><span class="nav-number">3.0.17.</span> <span class="nav-text">[754] 到达终点数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">3.0.18.</span> <span class="nav-text">[50] 快速幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#829-%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E6%B1%82%E5%92%8C"><span class="nav-number">3.0.19.</span> <span class="nav-text">[829] 连续整数求和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#400-%E7%AC%ACN%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">3.0.20.</span> <span class="nav-text">[400] 第N个数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#233-%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">3.0.21.</span> <span class="nav-text">[233] 数字1的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="nav-number">3.0.22.</span> <span class="nav-text">[43] 字符串相乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B9%98%E9%99%A4%E7%9A%84%E9%99%A4%E6%B3%95"><span class="nav-number">3.0.23.</span> <span class="nav-text">不使用乘除的除法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0"><span class="nav-number">3.0.24.</span> <span class="nav-text">[166] 分数到小数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0%E2%80%94%E2%80%94%E6%8C%89%E8%B5%B7%E7%82%B9%E5%88%86%E7%B1%BB"><span class="nav-number">3.0.25.</span> <span class="nav-text">[149] 直线上最多的点数——按起点分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#810-%E9%BB%91%E6%9D%BF%E5%BC%82%E6%88%96%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%89"><span class="nav-number">3.0.26.</span> <span class="nav-text">[810] 黑板异或游戏（位运算）</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>

    
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Like</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">364.5k</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("q4Cb3wR0nqm135LmdEWo9GrD-gzGzoHsz", "CtoawzwWheAQhgeEYEa1nDYn");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  <!-- 背景动画 -->
  <!-- <script type="text/javascript" src="/js/src/love.js"></script> -->

</body>
</html>


